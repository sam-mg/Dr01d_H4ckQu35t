# Challenge0x01

Let's dive into the source code and break it down for easier understanding:
```java
public class MainActivity extends AppCompatActivity {
    public void onCreate(Bundle bundle) {
        final int i = get_random();
        button.setOnClickListener(new View.OnClickListener() { // from class: com.ad2001.frida0x1.MainActivity.1
            public void onClick(View view) {
                String obj = editText.getText().toString();
                if (TextUtils.isDigitsOnly(obj)) {
                    MainActivity.this.check(i, Integer.parseInt(obj));
                } else {
                    Toast.makeText(MainActivity.this.getApplicationContext(), "Enter a valid number !!", 1).show();
                }
            }
        });
    }
    int get_random() {
        return new Random().nextInt(100);
    }
    void check(int i, int i2) {
        if ((i * 2) + 4 == i2) {
            Toast.makeText(getApplicationContext(), "Yey you guessed it right", 1).show();
            return;
        }
        Toast.makeText(getApplicationContext(), "Try again", 1).show();
    }
}
```
For clarity, Iâ€™ve simplified the code so you can easily grasp its structure and functionality.  
The challenge is clear: since brute-forcing every possible number is inefficient, we need to hook either the `get_random()` method or the `check()` method.  

---
**Hooking `get_random()`**  
By hooking into the `get_random()` method, we can intercept and manipulate the random value it generates. Here's a JavaScript snippet to accomplish this using Frida:
```js
Java.perform(() => {
    const Activity = Java.use('com.ad2001.frida0x1.MainActivity');
    Activity.get_random.implementation = function () {
        send('Inside the get_random');
        var randomNumber = this.get_random();
        console.log('Random number generated: ' + randomNumber);
        return randomNumber;
    };
});
```
This script hooks into `MainActivity` and intercepts the random number generated by `get_random()`. It logs the number and returns it as usual. Alternatively, we can force the method to return a specific value:
```js
Java.perform(() => {
    const Activity = Java.use('com.ad2001.frida0x1.MainActivity');
    Activity.get_random.implementation = function () {
        send('Inside get_random');
        return 0;
    };
});
```
With this tweak, the method will always return `0`, allowing us to easily calculate the required input to win the game. The simplicity of this approach makes it a powerful technique.

---
**Hooking `check()`**  
Alternatively, we can hook into the `check()` method, bypassing the need to guess the correct input entirely:
```js
Java.perform(() => {
    const Activity = Java.use('com.ad2001.frida0x1.MainActivity');
    Activity.check.overload('int','int').implementation = function (a,b) {
    send('Inside check method');
    this.check(4, 12);
    };
});
```
Here, regardless of the user's input, the method is forced to validate the correct answer, ensuring success every time. This method is effective when you want to ensure the desired outcome.
![](Challenge0x01/ScreenShots/Result.jpg)

Both methods demonstrate the power and flexibility of function hooking. Whether you choose to manipulate the random number generator or force a successful check, the key takeaway is understanding how to hook into functions to achieve your goals.

Happy hooking!